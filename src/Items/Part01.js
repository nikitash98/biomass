/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.12 public/Part_01.glb
*/

import React, { useRef } from 'react'
import { useGLTF, useAnimations, Html, Image, Box, PerspectiveCamera, OrthographicCamera} from '@react-three/drei'
import { playAnimations, setAnimationTime } from '../3D_Components/AnimationUtilities'
import { useEffect } from 'react'
import { useFrame, useThree } from 'react-three-fiber'
import slides from "../slides.json"
import { lerp } from 'three/src/math/MathUtils'
import data from '../Overlay/data.json';
import * as THREE from 'three'


export function Part01(props) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('Part01.glb')
  const { actions } = useAnimations(animations, group)
  const imageRef_one = useRef()
  const imageRef_two = useRef()
  let hiddenClass = (props.counter != props.previousCounter.current) ? 'box_name hidden' : "box_name ";
  
  const hiddenArtificial = "box_name artificial_name"
  const percentage_of_animation_played = useRef(0)
  let highlighted = slides[props.counter]["highlighted"]
  let divRefs = props.divRefs
  let quantities = slides[props.counter]["quantities"]
  console.log(props.counter)
  console.log(props.previousCounter.current)

  console.log([props.previousCounter.current, props.counter].sort().toString() == [22, 23].toString())
  const transp_material = new THREE.MeshStandardMaterial({color: 0x626967, opacity: 0.5, transparent: true})

  let animationSpeed = 1
  console.log(props.counter)
  let click_var = 1.0
  const camRef = useRef()
  const invizMaterial = new THREE.MeshStandardMaterial({opacity:0, transparent:true})
  const set_views = {
    "tree": [9],
    "boxes": [10, 11,12, 13, 14, 15, 16, 17, 18, 19, 20, ],
    "rising_boxes": [22,23],
    "end_view": [29,31,32,31,30]

    }
  const { viewport } = useThree();


  const handleAnimalHover = (e) => {
    console.log(e)
    e.stopPropagation()
    document.body.style.cursor = 'pointer'
    props.setHovered(["Animals"])
    props.setSelectionSet(props.divRefs["Animals"])
  }

  const car_offset = 0.0
  let boxes = Object.keys(data)

  boxes = boxes.filter(function (box_name) {
    return box_name !== 'Animals';
  });
  console.log([props.counter, props.previousCounter.current].sort() == [22, 23])
  console.log([props.counter, props.previousCounter.current].sort())
  console.log([22,23].toString() === [22,23].toString())
  let artificialBoxes = ["Cars", "Bricks","Metals","Asphalt","Aggregates", "Concrete", "Plastics"]
  let title_positions = {
    "Annelids": [-0.3, .3, .3],
    "Arthropods": [-0.3, .3, .3],
    "Animals": [-.5, 0, 1.2],
    "Plants": [+1.2, +1, +1.2],
    "LUCA": [-1, -1, 0.9],
    "Viruses": [-.3, 0.31, 0.3],
    "Protists": [+.75, 1, .8],
    "Bacteria": [-2, 2.2, 2.1],
    "Fungi": [1.4, 1, 1.2],
    "Archaea": [-1, 1, 1],
    "Cnidarians": [-.3, .3, .32],
    "Fish": [-.5, .5, -.5],
    "Humans": [-.2, .4, .2],
    "Livestock": [-.3, .3, .25],
    "Marine_Arthropods": [-.5, .7, .5],
    "Mollusks": [-.3, .5, .3],
    "Nematodes": [-.3, .1, .2],
    "Wild_Birds": [0.0, .3, .2],
    "Wild_Mammals": [-0.2, .2, .2],
    "Concrete": [.5, -.55, .5],
    "Bricks": [.5, -.55, .5],
    "Cars": [.5, -.5, .5],
    "Metals": [.5, -.55, .5],
    "Aggregates": [.5, -.55, .5],
    "Asphalt": [.5, -.55, .5],
    "Plastics": [.5, -.55, .5]
  }


  let title_rotations = {
    "Annelids": [-Math.PI/2, 0, 0 ],
    "Arthropods": [-Math.PI/2, 0, 0 ],
    "Animals": [-Math.PI/2, 0, 0 ],
    "Plants": [-Math.PI/2, 0,Math.PI/2],
    "LUCA": [0, 0,0],
    "Viruses": [-Math.PI/2, 0,0],
    "Protists": [-Math.PI/2, 0,Math.PI/2],
    "Bacteria": [-Math.PI/2, 0,0],
    "Fungi": [-Math.PI/2, 0,Math.PI/2],
    "Archaea": [-Math.PI/2, 0,0],
    "Cnidarians": [-Math.PI/2, 0, 0 ],
    "Fish": [-Math.PI/2, 0,-Math.PI/2],
    "Humans":[-Math.PI/2, 0, 0],
    "Livestock": [-Math.PI/2, 0,0],
    "Marine_Arthropods": [-Math.PI/2, 0,0],
    "Mollusks": [-Math.PI/2, 0,0],
    "Nematodes": [-Math.PI/2, 0,0],
    "Wild_Birds": [-Math.PI/2, 0, 0 ],
    "Wild_Mammals": [-Math.PI/2, 0, 0 ],
    "Concrete": [0, 0, 0 ],
    "Bricks": [0, 0, 0 ],
    "Cars": [0, 0, 0 ],
    "Metals": [0, 0, 0 ],
    "Aggregates": [0, 0, 0 ],
    "Asphalt": [0, 0, 0 ],
    "Plastics": [0, 0, 0 ],

  }

  let weight_positions = {
    "Annelids": [0, 0, -.4],
    "Arthropods": [0, 0, -.4],
    "Animals": [-1.3, 0, 0],
    "Plants": [-1.3, 0, 0],
    "LUCA": [0, 1.5, 0],
    "Viruses": [0, 0, -.4],
    "Protists": [-1, 0, 0],
    "Bacteria": [0, 0, -2.6],
    "Fungi": [-1.3, 0, 0],
    "Archaea": [0, 0, -1.4],
    "Cnidarians": [0, 0, -.4],
    "Fish": [0.7, 0, 0],
    "Humans": [0, 0, -.4],
    "Livestock": [0, 0, -.4],
    "Marine_Arthropods":[0, 0, -.6],
    "Mollusks": [0, 0, -.4] ,
    "Nematodes":[0, 0, -.4],
    "Wild_Birds": [0, 0, -.2],
    "Wild_Mammals": [0, 0, -.2],
    "Concrete": [0, 0.65, 0],
    "Bricks": [0, 0.65, 0],
    "Cars": [0, 0.6, 0],
    "Metals": [0, 0.6, 0],
    "Aggregates":[0, 0.65, 0],
    "Asphalt": [0, 0.65, 0],
    "Plastics": [0, 0.6, 0]
  }


  const flatten_name = (entry_name) => {
    return entry_name.replace(/ /g,"_")
  }


  let change = (viewport.width/viewport.height)

  if(!change){
    change = 0
  } else {
    change = 10/Math.pow((viewport.width/viewport.height), 3.0)      
  }
  const quant_value = useRef(0)
  const asphalt_value = useRef(0)
  const metal_value = useRef(0)
  const brick_value = useRef(0)
  const aggregate_value = useRef(0)
  const concrete_value = useRef(0)

  const artificial_values = useRef({
    "Asphalt": 0,
    "Metals": 0,
    "Concrete": 0,
    "Aggregates": 0,
    "Bricks": 0,
    "Plastics": 0

  })

  const animal_click = () => {
    if(set_views["boxes"].includes(props.counter)) {
      props.setScrubbing(false)
      props.setCounter(props.counter + 1)
      props.setcounterHit(false)
    }
    if(props.counter == 1) {
      props.setScrubbing(false)
      props.setcounterHit(false)
      props.setCounter(props.counter + 1)
    }
  }

  const rise_percentage = (value) => {
    let start_time = slides[22]["animationTime"] + car_offset
    let end_time = slides[23]["animationTime"]
    let length = end_time - start_time
    let cur_value = value - start_time
    let perc = cur_value/length
    return perc
  }

  const flatYear = (value) => {
    let perc = rise_percentage(value)
    return perc//Math.max(Math.min(1900 + Math.round(120 * perc), 2020),1900)
  }

  const exponentialLaw = (a, b, x) => {
    return a * Math.pow(b, x)
  }
  const e_square_function = (a, b, c, x) => {
    return a * Math.pow(Math.E, b * Math.pow((x + c), 2))
  }
  useEffect( () =>{
    playAnimations(actions)
    setAnimationTime(actions, slides[props.counter]["animationTime"])
  }, [])

  useFrame((state, delta)=> {

   if(props.previousCounter.current != props.counter) {
    let anim_length = Math.abs(slides[props.counter]["animationTime"] - slides[props.previousCounter.current]["animationTime"])
    percentage_of_animation_played.current += animationSpeed/anim_length * delta
    
    if(props.scrubbing || Math.abs(props.previousCounter.current - props.counter)> 1) {
      props.animationTime.current = slides[props.counter]["animationTime"]
      props.previousCounter.current = props.counter
      props.setcounterHit(true)

    } else {
      props.animationTime.current = lerp(slides[props.previousCounter.current]["animationTime"], slides[props.counter]["animationTime"], Math.min(percentage_of_animation_played.current, 1))
    }

    setAnimationTime(actions, props.animationTime.current)

    if(percentage_of_animation_played.current >= 1.0) {
      props.previousCounter.current = props.counter
      percentage_of_animation_played.current = 0
      hiddenClass = "box_name hidden" 
      props.setcounterHit(true)
    }
   }

   if (imageRef_one.current) {
    imageRef_one.current.material.opacity = (Math.abs(Math.sin(state.clock.getElapsedTime() * 3))) * 0.4 + 0.6;

   }
   if (imageRef_two.current) {
    imageRef_two.current.material.opacity = (Math.abs(Math.sin(state.clock.getElapsedTime() * 3))) * 0.4 + 0.6;

   }

    if(set_views["rising_boxes"].includes(props.counter)) {
      props.setYearPercentage(flatYear(props.animationTime.current))
      quant_value.current = rise_percentage(props.animationTime.current)
      artificial_values.current["Concrete"] = e_square_function(71971.169, -0.149, -8.720, rise_percentage(props.animationTime.current) * 2 * 1.025 + 1)
      artificial_values.current["Aggregates"] = e_square_function(815.706, -0.227, -4.816, rise_percentage(props.animationTime.current) * 2 * 1.025 + 1)
      artificial_values.current["Bricks"] = e_square_function(15.258, 0.315, -0.612, rise_percentage(props.animationTime.current) * 2 * 1.025 + 1)
      artificial_values.current["Metals"] = e_square_function(121.671, -0.184, -5.488, rise_percentage(props.animationTime.current) * 2 * 1.025 + 1)
      artificial_values.current["Asphalt"] = e_square_function(65.102, -1.004, -3.040, rise_percentage(props.animationTime.current) * 2 * 1.025  + 1)
      artificial_values.current["Plastics"] = e_square_function(11.000, -1.720, -3.238, rise_percentage(props.animationTime.current) * 2 * 1.025 + 1)

    }
  })


  if(set_views["tree"].includes(props.counter)) {
    title_positions["Fungi"] = [1.2, 1, 1]
    title_positions["Archaea"] = [-1, 0, 1.2]
    title_positions["Bacteria"] = [-2, 0, 3.2]



  }
  if(set_views["boxes"].includes(props.counter)) {
    title_positions["Plants"] = [-1.25, +1, +1.2]
    title_positions["Protists"] = [-1.25, +1, 0]
    title_positions["Animals"] = [1.85, -0.6, -1]

  }

  if(set_views["rising_boxes"].includes(props.counter)) {
    title_positions["Metals"] =[-0.4, 0.7, 0]
    title_positions["Asphalt"] =[-0.4, 0.7, 0]
    title_positions["Bricks"] =[-0.4, 0.7, 0]
    title_positions["Aggregates"] =[-0.4, 0.7, 0]
    title_positions["Concrete"] =[-0.3, 0.7, 0]
    title_positions["Plastics"] =[-0.4, 0.7, 0]

  }

  if(set_views["end_view"].includes(props.counter)) {
    title_positions["Plastics"] =[0.3, 0.9, 0]
    title_positions["Metals"] =[0.4, 0.9, 0]
    title_positions["Asphalt"] =[0.7,0.9 , 0]
    title_positions["Bricks"] =[0.8, 0.8, 0]
    title_positions["Plants"] = [-1.35, +1, +1.2]
    title_positions["Protists"] = [-1.5, 0, -.2]
    title_positions["Fungi"] = [1.2, 0, 1.2]

  }

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
      <PerspectiveCamera name="Camera" makeDefault 
      far={1000} near={0.1} fov={26.369 +change} 
      position={[0.759, 19.945, 20.304]} rotation={[-0.2, 0, 0]} scale={5.334} 
      />


    {boxes.map((name, i) => {
        let flat_name = flatten_name(name)
        let currentClass = hiddenClass
        let icon_mat = materials.Icons
        let is_artificial = artificialBoxes.includes(name)
        if(is_artificial) {
          currentClass = hiddenArtificial
          icon_mat = materials["Material.008"]
        }

        let trans_amount = "0%"
        if(is_artificial) {
          trans_amount = "-120%"
        }
        icon_mat.toneMapped = false;
        let human_title = name
        if(name == "Humans" && props.counter >= 20 && props.previousCounter.current > 19) {
          human_title = "All Humans"
          currentClass = currentClass + " all_humans_type"
        } 
        let weight_val = data[name].weight

        if(Object.keys(artificial_values.current).includes(name) &&
          set_views["rising_boxes"].includes(props.counter)){
          weight_val = Math.round(artificial_values.current[name])
        }

        if(props.hovered.includes(name)){
          currentClass += " hovered_name"
        }
        if(highlighted.includes(name)) {
          currentClass += " highlighted_name"
        }
        return (
            <mesh name = {flat_name} geometry={nodes[flat_name].geometry} key = {i}
            material = {highlighted.includes(name) ? transp_material : nodes[flat_name].material}
            morphTargetDictionary={false? null:nodes["Metals"].morphTargetDictionary} 
            morphTargetInfluences={ false? null: nodes["Metals"].morphTargetInfluences} 
             position = {nodes[flat_name].position}
            rotation = {nodes[flat_name].rotation}
             frustumCulled = {false}
            onPointerOver = {
              ([props.counter, props.previousCounter.current].sort().toString() == [22, 23].toString())
              ? null:props.handleHover} onPointerOut = {props.handleUnhover}
            
            ref = {ref => divRefs.current[name] = ref} 
            >
          <mesh name={flat_name + "_Icon"} geometry={nodes[flat_name + "_Icon"].geometry} material={icon_mat} 
          position={nodes[flat_name + "_Icon"].position} rotation={nodes[flat_name + "_Icon"].rotation} scale={nodes[flat_name + "_Icon"].scale} />
            <Html 
                style={{
                  transition: 'all 0.2s',
                  transform: 'translate(-50%, -100%)'
                }}
                zIndexRange={[100, 100]}
                position = {weight_positions[flat_name]}
                className= {(props.hovered.includes(name) || quantities.includes(name)) ? "box_value" : "box_value hide_box"} 
                >
                <h1>{weight_val} Gt </h1>
            </Html>

            {/*
            rotation = {nodes[flat_name].rotation}

            */}
            {((!is_artificial || props.counter > 23) || (flat_name == "Cars")) && (

            <Html position = {title_positions[flat_name]} 
            scale = {0.4/nodes[flat_name].scale.x}
            style={{
              transform: 'translate('+ trans_amount + ', 0%)'
            }}
            onMouseEnter={()=> {console.log("ABC")}}

            zIndexRange={[0, 20]}
            className={currentClass}>
                <h1>{human_title}</h1>
                
            </Html>
            )}





            </mesh>       
            

            
        )
    })}

    {([props.previousCounter.current, props.counter].sort().toString() == [22, 23].toString()
    ||
    [props.previousCounter.current, props.counter].sort().toString() == [21, 22].toString()
    || (props.previousCounter.current == props.counter && [22, 23].includes(props.counter))
    ) && (
      <>
      {props.animationTime.current > 25.8 && (
        <Html position={[-2, 1, 5]} className={"box_name artifical_name"}>
          <h1>
            Plastics
          </h1>
        </Html>

      )}

      

      {props.animationTime.current > 25.8 && (

        <Html position={[1.6, 1, 4]} className={"box_name artifical_name"}>
            <h1>
              Metals
          </h1>
        </Html>
      )}


      {props.animationTime.current > 25.8 && (

        <Html position={[4.6, 1, 2]} className={"box_name artifical_name"}>
          <h1>
            Asphalt
          </h1>
        </Html>
      )}


      {props.animationTime.current > 25.8 && (

        <Html position={[9, 1.0, -1]} className={"box_name artifical_name"}>
          <h1>
            Bricks
          </h1>
        </Html>
      )}

      {props.animationTime.current > 25.8 && (
        <Html position={[14, 1.0, -3.0]} className={"box_name artifical_name"}>
          <h1>
            Aggregates
          </h1>
        </Html>
      )}
      {props.animationTime.current > 25.8 && (

        <Html position={[20, 1.0, -6.0]} className={"box_name artifical_name"}>
          <h1>
            Concrete
          </h1>
        </Html>
      )}

      </>

          )}

          <group name="Year" position={[0, 1.05, -5.872]} rotation={[0, Math.PI / 6, 0]} scale={1.711} 
          >

          <Html position = {[0, 0, 0]}
            occlude = {true}
            transform>
                    <div className = "yearCounter" >
                    <h1>year {(Math.max(Math.min(1900 + Math.round(123 * flatYear(props.animationTime.current)), 2023),1900)).toString()}</h1>
                    </div>
            </Html>
            
                </group>

  <group name="Empty" position={[0, 1.148, 0]} scale={1.086}
  >
    <group name="Armature" position={[0, -1.057, 0]} scale={0.921}
    >
      <primitive object={nodes.Bone} />
      <primitive object={nodes.Bone001} />
      <primitive object={nodes.neutral_bone} />
      <Box position={[0, 0.7, 0]} scale={1.4}
      onPointerOver={handleAnimalHover}
      onPointerOut={props.handleUnhover}
      onClick={animal_click}

      material={invizMaterial}
      
      />

      <skinnedMesh name="Animals" geometry={nodes.Animals.geometry} 
    
      material={highlighted.includes("Animals") ? transp_material : materials.Animals} 
      
      
      skeleton={nodes.Animals.skeleton}
          ref = {ref => divRefs.current["Animals"] = ref} 
          //onPointerOver = {props.handleHover} 
          //onPointerOver={()=>{console.log("OVER")}}
          //onPointerOut = {props.handleUnhover}
          frustumCulled={false}
          >
        <mesh name="Animals_Icon" geometry={nodes.Animals_Icon.geometry} material={materials.Icons} position={[0, 0, -0.018]} />
      </skinnedMesh>


      <Html position = {title_positions["Animals"]} 
            style={{
              transform: 'translate(0%, 0%)'
            }}
            onMouseEnter={()=> {console.log("ABC")}}

            zIndexRange={[0, 20]}
            className={hiddenClass}>
                <h1>Animals</h1>
                
            </Html>
    </group>
  </group>
  <mesh name="Transparent001" geometry={nodes.Transparent001.geometry} material={materials.Transparent} morphTargetDictionary={nodes.Transparent001.morphTargetDictionary} morphTargetInfluences={nodes.Transparent001.morphTargetInfluences} position={[11.839, -1.79, -5.518]} rotation={[0, 0.488, 0]} scale={5.779} />
  <mesh name="Trans" geometry={nodes.Trans.geometry} material={materials.Transparent} morphTargetDictionary={nodes.Trans.morphTargetDictionary} morphTargetInfluences={nodes.Trans.morphTargetInfluences} position={[7.069, -0.63, -1.784]} rotation={[0, 0.488, 0]} scale={3.583} />
  <mesh name="Metals001" geometry={nodes.Metals001.geometry} material={materials.Transparent} morphTargetDictionary={nodes.Metals001.morphTargetDictionary} morphTargetInfluences={nodes.Metals001.morphTargetInfluences} position={[-0.073, -0.12, 2.671]} rotation={[0, 0.488, 0]} scale={[2.692, 2.555, 2.555]} />
  <mesh name="Plastics001" geometry={nodes.Plastics001.geometry} material={materials.Transparent} morphTargetDictionary={nodes.Plastics001.morphTargetDictionary} morphTargetInfluences={nodes.Plastics001.morphTargetInfluences} position={[-2.585, 0.266, 4.35]} rotation={[0, 0.488, 0]} scale={1.623} />
  <mesh name="Transparent" geometry={nodes.Transparent.geometry} material={materials.Transparent} position={[18.217, -2.301, -9.382]} rotation={[0, 0.488, 0]} scale={6.499} />

  <mesh name="Trans2" geometry={nodes.Trans2.geometry} material={materials.Transparent} morphTargetDictionary={nodes.Trans2.morphTargetDictionary} morphTargetInfluences={nodes.Trans2.morphTargetInfluences} position={[3.336, -0.551, 0.578]} rotation={[0, 0.488, 0]} scale={3.191} />

  <mesh name="Plane001" geometry={nodes.Plane001.geometry} material={materials.Tree} position={[1.247, -4.049, 1.436]} rotation={[Math.PI / 2, 0, 0]} scale={[6.678, 3.04, 3.047]} />
  <mesh name="Plane" geometry={nodes.Plane.geometry} material={materials.Rollout} position={[0.976, -2.488, 9.278]} rotation={[Math.PI / 2, 0, 0]} scale={[0.009, 0.723, 0.075]} />
    {((props.counter == 1 || props.counter == 10) && (props.counter == props.previousCounter.current)) && (
      <>

      <Image ref={imageRef_one} transparent {...props} position={props.counter == 10 ? [-1.0, 2.0, 10]:[-1.5, 1.5, 0] } scale={1.0} url="Icon/Right_Caret_Outline.svg"/>
      <Image ref={imageRef_two} transparent {...props} rotation = {[0, 0, Math.PI]} position={props.counter == 10 ? [1.5,2.0, 10]:[1.5, 1.5, 0]} scale={1.0} url="Icon/Right_Caret_Outline.svg"/>



      </>
    )}
    

      </group>
    </group>
  )
}

useGLTF.preload('Part01.glb')
